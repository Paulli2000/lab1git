---
title: "Lab 1"
author: "Paul Li"
date: "2025-08-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

## package setup 
```{r}
# Load libraries used throughout
library(readr) # for read_csv
library(dplyr) # data wrangling
library(janitor) # clean names (if needed)
library(stringr) # string helpers
library(forcats) # factor helpers
library(ggplot2) # visualization for Q7
```


## read the data file
```{r, chunk7, message=FALSE}
library(readr)
C1survey <-
 read_csv(
   "https://github.com/kijohnson/Advanced-Data-Analysis/raw/refs/heads/main/Class%201%20Survey%20Fall%202025%202.csv"
   )
```

## Determine variables and observations 
```{r}
# a) number of observations (rows)
n_obs <- nrow(C1survey)
# b) number of variables (columns)
n_vars <- ncol(C1survey)


# Display a simple summary table
summary_dims <- tibble::tibble(
metric = c("Observations", "Variables"),
value = c(n_obs, n_vars)
)
summary_dims
```
## Rename and display 
```{r}
# Capture original names so we can show the mapping
orig_names <- names(C1survey)


# Desired new names in the specified order
new_names <- c(
"id", "like_cats", "like_dogs", "have_desert", "slogan", "fav_day",
"larkORowl", "fav_food", "fav_drink", "fav_season", "fav_month",
"hobby", "program", "specialization", "stat_software", "R_exp",
"coding_comfort", "coding_length", "top_three", "public_health_interest",
"fav_num", "bday", "bmonth", "country", "state", "city",
"highest_educ_level"
)


# Safety check: if counts differ, fall back to a safe cleaning approach
if (length(orig_names) == length(new_names)) {
names(C1survey) <- new_names
} else {
# Fallback: keep original count; clean, then pad/truncate safely
names(C1survey) <- janitor::make_clean_names(orig_names)
warning("Column count does not match provided name list; applied clean_names() instead.")
}


# Show a name mapping table to verify the rename
name_map <- tibble::tibble(
original = orig_names,
renamed = names(C1survey)
)
name_map
```

## Write code to determine and display the number of factor, integer, numerical, and character variables there are in the C1survey dataset
```{r}
# Find out how many variables in the dataset are factors, integers, numerics, or characters. Report the counts for each type.

col_classes <- sapply(C1survey, function(x) class(x)[1])

bucket <- ifelse(col_classes %in% "factor", "factor",
          ifelse(col_classes %in% c("integer","integer64"), "integer",
          ifelse(col_classes %in% c("numeric","double"), "numeric",
          ifelse(col_classes %in% "character", "character", col_classes))))

# counts of factor / integer / numeric / character (and any other types if present)
table(bucket)

```

## Audit, clean, and summarize bday + bmonth (base R only)
```{r}
# Inspect the bday (day of month) and bmonth (month) variables for invalid or missing entries. Remove out-of-range values (e.g., day > 31 or month > 12). After cleaning, calculate the median birth day and median birth month.

# Coerce to numeric robustly (strip non-digits like "07", "Mar", etc.)
to_int <- function(x) {
  x_chr <- as.character(x)
  x_chr <- gsub("[^0-9]", "", x_chr)   # keep digits only
  x_num <- suppressWarnings(as.integer(x_chr))
  x_num
}

C1survey$bday   <- to_int(C1survey$bday)
C1survey$bmonth <- to_int(C1survey$bmonth)

# a) Inspect raw distributions (including missing)
cat("Raw bday (with NAs):\n");   print(table(C1survey$bday,   useNA = "ifany"))
cat("\nRaw bmonth (with NAs):\n"); print(table(C1survey$bmonth, useNA = "ifany"))

# b) Cleaning plan (documented here and implemented below):
# - Set out-of-range values to NA:
#   * bday must be in 1..31
#   * bmonth must be in 1..12
# - Do not guess/recoding beyond range checks.

# Implement cleaning
C1survey$bday[  !(is.na(C1survey$bday)   | (C1survey$bday   >= 1 & C1survey$bday   <= 31))] <- NA_integer_
C1survey$bmonth[!(is.na(C1survey$bmonth) | (C1survey$bmonth >= 1 & C1survey$bmonth <= 12))] <- NA_integer_

# Re-check after cleaning
cat("\nCleaned bday (with NAs):\n");   print(table(C1survey$bday,   useNA = "ifany"))
cat("\nCleaned bmonth (with NAs):\n"); print(table(C1survey$bmonth, useNA = "ifany"))

# c) Medians after cleaning
median_bday   <- median(C1survey$bday,   na.rm = TRUE)
median_bmonth <- median(C1survey$bmonth, na.rm = TRUE)

cat("\nMedian birthday day (1–31): ", median_bday, "\n", sep = "")
cat("Median birth month (1–12): ",    median_bmonth, "\n", sep = "")

# --- Plots: distributions of cleaned bday and bmonth ---

op <- par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))  # 1 row, 2 plots

# Histogram of day of month (1–31)
hist(C1survey$bday,
     breaks = seq(0.5, 31.5, by = 1),
     main = "Birth Day (1–31)",
     xlab  = "Day of Month",
     ylab  = "Count")

# Histogram of birth month (1–12)
hist(C1survey$bmonth,
     breaks = seq(0.5, 12.5, by = 1),
     main = "Birth Month (1–12)",
     xlab  = "Month",
     ylab  = "Count",
     xaxt  = "n")
axis(1, at = 1:12, labels = 1:12)

par(op)  # reset layout


```

## Create bseason, cross-tab with bmonth, and column totals (base R only)
```{r}
# Create a new variable (bseason) that assigns each respondent’s birth month to a season (Winter, Spring, Summer, Fall). Display a month-by-season table to confirm coding, then total the counts per season.

# a) Create a lookup vector: month -> season
month_to_season <- c(
  "Winter","Winter","Spring","Spring","Spring",
  "Summer","Summer","Summer",
  "Fall","Fall","Fall","Winter"
)
names(month_to_season) <- as.character(1:12)

# Assign season using the lookup
C1survey$bseason <- ifelse(is.na(C1survey$bmonth), NA,
                           month_to_season[as.character(C1survey$bmonth)])

# b) Cross-tab of months (rows) by seasons (columns)
month_x_season <- table(C1survey$bmonth, C1survey$bseason, useNA = "ifany")
month_x_season

# c) Column totals with addmargins
with_margins <- addmargins(month_x_season, margin = 2)
with_margins

# d) Season totals (clean vector) + one-liner
season_totals <- colSums(month_x_season, na.rm = TRUE)
season_totals

cat("Classmates per season -> ",
    paste(names(season_totals), season_totals, collapse = "; "),
    "\n")

```

## Question: Are more classmates morning larks or night owls, and does this differ by program?
```{r}
# Pick a variable to analyze. Here I examine whether classmates identify as morning larks or night owls (larkORowl). Summarize the overall distribution, compare by program, and visualize the results to see if patterns differ between groups.

# a) Overall distribution (simple one-liner)
table(C1survey$larkORowl, useNA = "ifany")

# Optional: quick pie chart
# pie(table(C1survey$larkORowl, useNA = "ifany"),
#     main = "Morning Larks vs Night Owls")

# b) Cross-tab with program
tab_prog_lark <- table(C1survey$program, C1survey$larkORowl, useNA = "ifany")
tab_prog_lark

# c) Proportions by program (row percentages in one call)
prop.table(tab_prog_lark, margin = 1)

# d) One-line textual answer (no sorting, just pick max directly)
counts <- table(C1survey$larkORowl, useNA = "ifany")
most_common <- names(counts)[which.max(counts)]
cat("Answer: The most common type overall is", most_common,
    "with", max(counts), "classmates.\n")

# ---Plots: lark vs owl overall and by program ---

# Overall counts
lark_counts <- table(C1survey$larkORowl, useNA = "no")

# 1) Overall barplot
barplot(lark_counts,
        main = "Morning Lark vs Night Owl (Overall)",
        xlab = "Type",
        ylab = "Count",
        las  = 2)

# 2) Stacked barplot by program
tab_prog_lark <- table(program = C1survey$program,
                       type    = C1survey$larkORowl,
                       useNA   = "no")

barplot(t(tab_prog_lark),
        main = "Lark vs Owl by Program",
        xlab = "Program",
        ylab = "Count",
        las  = 2,
        legend = TRUE,
        args.legend = list(x = "topright", bty = "n"))

# 3) 100% stacked (proportions by program)
prop_prog_lark <- prop.table(tab_prog_lark, margin = 1)
barplot(t(prop_prog_lark),
        main = "Lark vs Owl by Program (Proportions)",
        xlab = "Program",
        ylab = "Proportion",
        las  = 2,
        legend = TRUE,
        args.legend = list(x = "topright", bty = "n"))
```

```{r}
# --- Save the cleaned/modified dataset to CSV ---
write.csv(C1survey,
          file = "C1survey_cleaned.csv",
          row.names = FALSE)

```

